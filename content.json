{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"耶！","text":"建好了！以后就用这个写吧！","link":"/article/耶！/"},{"title":"[译] TypeScript 3.6 Beta 发布","text":"原文：https://devblogs.microsoft.com/typescript/announcing-typescript-3-6-beta/ 今天我们很高兴地宣布 TypeScript 3.6 Beta 已经可以获取并使用。这个 beta 版本包含 TypeScript 3.6 的完整功能。在接下来的几周里我们会修复 bugs 同时增强候选正式版本的性能与稳定性，最终发布正式版本。 要开始使用这个 beta 版本，你可以通过 NuGet 或者执行以下的 npm 命令： 1npm install -g typescript@beta 获得编辑器支持： VS 2019/2017 按照 VS Code 和 Sublime Text 的指引 接下来让我们来看看 3.6 的新特性！ 更严格的生成器TypeScript 引入了对迭代器和生成器函数更严格的检查。在早期版本中，生成器的用户无法分辨一个值是 yield 产生的还是 return 产生的。 123456789101112function* foo() &#123; if (Math.random() &lt; 0.5) yield 100; return \"Finished!\"&#125;let iter = foo();let curr = iter.next();if (curr.done) &#123; // TypeScript 3.5 及更早版本认为这是 'string | number'。 // 因为 done 是 true 所以现在它会知道它是 string 了！ curr.value&#125; 此外，生成器会假定 yield 的类型总是 any。 12345678function* bar() &#123; let x: &#123; hello(): void &#125; = yield; x.hello();&#125;let iter = bar();iter.next();iter.next(123); // oops! runtime error! 在 TypeScript 3.6 中，检查器会知道在第一个例子中 curr.value 应是 string ，并且在最后一个例子中对 next() 的调用会正确地出现错误。这要归功于对 Iterator 与 IteratorResult 的类型定义的一些变化，包括增加了新的类型参数和一个新的类型，TypeScript 用来表示生成器的 Generator 类型。 Iterator 类型现在允许用户指定生成数据的数据类型（yielded type）、返回数据的数据类型（returned type）以及 next 方法接收数据的数据类型。 123456interface Iterator&lt;T, TReturn = any, TNext = undefined&gt; &#123; // 接收 0 或 1 个参数（不接受 undefined） next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;; return?(value?: TReturn): IteratorResult&lt;T, TReturn&gt;; throw?(e?: any): IteratorResult&lt;T, TReturn&gt;;&#125; 在此工作之上，新的 Generator 类型是一个总是拥有 return 和 throw 方法的 Iterator，并且是可迭代对象（iterable）。 1234567interface Generator&lt;T = unknown, TReturn = any, TNext = unknown&gt; extends Iterator&lt;T, TReturn, TNext&gt; &#123; next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;; return(value: TReturn): IteratorResult&lt;T, TReturn&gt;; throw(e: any): IteratorResult&lt;T, TReturn&gt;; [Symbol.iterator](): Generator&lt;T, TReturn, TNext&gt;;&#125; 为了区分返回值与生产值（yielded values）， TypeScript 3.6 会转换 IteratorResult 为一个可辨识联合类型（discriminated union type）： 1234567891011type IteratorResult&lt;T, TReturn = any&gt; = IteratorYieldResult&lt;T&gt; | IteratorReturnResult&lt;TReturn&gt;;interface IteratorYieldResult&lt;TYield&gt; &#123; done?: false; value: TYield;&#125;interface IteratorReturnResult&lt;TReturn&gt; &#123; done: true; value: TReturn;&#125; 简单来说，这意味着，当你直接处理它的时候，你可以适当地收窄迭代器产生的值。 为了正确地体现从 next() 传入给生成器的值类型，TypeScript 3.6 会推断生成器主体中的对 yield 的特定使用。 12345678function* foo() &#123; let x: string = yield; console.log(x.toUpperCase());&#125;let x = foo();x.next(); // 总是忽略对 next 的首次调用x.next(42); // 错误！ number 类型不能分配给 string 类型 如果想要显式指定，你可以使用显式的返回类型，以确保允许使用 yield 表达式返回的、产生的和计算的值类型。以下例子中，仅可以使用 boolean 调用 next()，并且视 done 的值而定，value 可以是 string 或 number。 1234567891011121314151617181920212223242526272829303132/** * - 生成 number * - 返回 string * - 允许传入 boolean */function* counter(): Generator&lt;number, string, boolean&gt; &#123; let i = 0; while (true) &#123; if (yield i++) &#123; break; &#125; &#125; return \"done!\";&#125;var iter = counter();var curr = iter.next()while (!curr.done) &#123; console.log(curr.value); curr = iter.next(curr.value === 5)&#125;console.log(curr.value.toUpperCase());// 打印出://// 0// 1// 2// 3// 4// 5// DONE! 更多细节，见这个 PR 。 更精确的数组展开在比 ES2015 更早的目标中，对 for/loop 这种结构和数组展开的输出会有点笨重，因此，TypeScript 默认使用更简单的输出，仅支持数组类型，同时，支持通过设置 --downlevelIteration 选项来支持迭代其它类型。当这个标记启用时，输出代码更精确，但体积更大。 默认关闭 --downlevelIteration 也能够很好地工作，因为一般来说，大多数目标指定为 ES5 的用户仅仅打算与数组一起使用可迭代结构，然而，曾经这种仅支持数组的输出，在边界状况还会有一些可察觉的差异。 例如： 1[...Array(5)] 等同于以下数组： 1[undefined, undefined, undefined, undefined, undefined] 然而，TypeScript 会转而将原始代码转换为以下代码： 1Array(5).slice(); 这有点不一样，因为 Array(5) 会生成一个长度为 5 的数组，但没有已定义的属性插槽！ 121 in [undefined, undefined, undefined] // true1 in Array(3) // false 同时当 TypeScript 调用 slice()，它会生成一个索引尚未设置的数组。 这些差异可能看起来有点难懂，但实际上是很多用户会碰到这种意想不到的未定义行为，与其使用 slice() 和内置函数，在旧目标中除了使用 --downlevelIteration，TypeScript 3.6 引入了一种新的 __spreadArrays 助手函数来精确地模拟 ES2015 中所发生的一切。__spreadArrays 同时在 tslib 中（如果想要更小的打包，值得看一看）。 更多信息，见这个相关 PR。 提升 Promise 周边的用户体验如今 Promise 是与异步数据一起工作的最常见手段之一，不幸的是，使用面向 Promise 的 API 常常令用户疑惑。TypeScript 3.6 引入了对处理不当的 Promise 的一些改进。 例如，用户常常会忘记使用 .then() 或忘记在将数据传递给另一个函数前 await 一个 Promise 的内容。TypeScript 专门优化了一些错误消息，同时会在你应该考虑使用 await 关键字的时候提醒你。 12345678910111213141516interface User &#123; name: string; age: number; location: string;&#125;declare function getUserData(): Promise&lt;User&gt;;declare function displayUser(user: User): void;async function f() &#123; displayUser(getUserData());// ~~~~~~~~~~~~~// 类型实参 Promise&lt;User&gt; 无法分配给类型形参 User。// ...// 你是否忘记使用 await？&#125; 同样常见的是在 await 或 .then() 一个 Promise 之前试图访问一个方法。以下是总多例子中的另一个例子，在此例子中我们可以做得更好： 12345678async function getCuteAnimals() &#123; fetch(\"https://reddit.com/r/aww.json\") .json() // ~~~~ // 在 Promise&lt;Response&gt; 类型中不存在 json 属性。 // // 你是否忘记使用 await？&#125; 这样做的目的是，当用户忘记了 await，至少这些信息能提供提供一个背景告诉我们怎么做。 不仅仅是提供发现的可能性，为了使你的生活更轻松点，除了提供对 Promise 更好的错误消息之外，我们在某些场景提供了快速修复： 更多细节，见最初的 issue 以及连接到它的 PR。 可感知分号的代码编辑Visual Studio 和 Visual Studio Code 这样的编辑器可以自动应用快速修复、重构和像自动从其他模块插入值等其他转换。这些转换是由 TypeScript 提供的，旧版本的 TypeScript 就无条件地添加分号到语句的结尾，但很可惜的是，它与很多用户所使用的代码风格指南不合，同时很多用户对编辑器插入分号感到不爽。 TypeScript 现在足够智能，在应用这些修改时，能够检测你的文件是否使用了分号。如果你的文件大体上缺少分号，TypeScript 就不会添加。 更多细节，见相关 PR。 重大变化以字符串“constructor”命名的方法为构造函数根据 EMCAScript 规范，不管是使用标识符还是字符串作为名称，类定义中名称为 constructor 的方法是构造函数： 12345class C &#123; \"constructor\"() &#123; console.log(\"I am the constructor now.\"); &#125;&#125; 一个值得注意的例外（同时也是绕过这个变化的变通方法）是使用一个运算结果为 constructor 是计算属性： 12345class D &#123; [\"constructor\"]() &#123; console.log(\"I'm not a constructor - just a plain method!\"); &#125;&#125; DOM 更新我们删除和修改了 lib.dom.d.ts 中的很多定义，包含（但不限于）以下： 删除了GlobalFetch，取而代之的是WindowOrWorkerGlobalScope。 删除了某些在 Navigator 下的非标准属性。 删除了experimental-webgl 上下文，取而代之的是 webgl 和 webgl2。 如果你发现了错误的更改，请提交 issue！ 不再合并 JSDoc 注释在 JavaScript 文件中，TypeScript 仅仅检查前面紧接着的 JSDoc 注释来确定所定义的类型： 123456789/** * @param &#123;string&#125; arg *//** * oh, hi, were you trying to type something? */function whoWritesFunctionsLikeThis(arg) &#123; // 'arg' has type 'any'&#125; 接下来是TypeScript 3.6 预计在八月底推出，在此几周之前发布 RC 版，我们希望你试一试 beta 版本同时让我们知道它到底如何，如果你有任何建议或碰到问题，不要介意浏览一下 issue tracker 和提交 issue！ Happy Hacking! – Daniel Rosenwasser 和 TypeScript 团队","link":"/article/ts-3.6-beta/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/其他/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Translations","slug":"Translations","link":"/tags/Translations/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/其他/"},{"name":"Coding","slug":"Coding","link":"/categories/Coding/"}]}